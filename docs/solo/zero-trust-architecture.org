* SPIFFE (Secure Production Identity Framework for everyone)
What is SPIFFE ?

We might identify a workload using an IP address and port (or even a fully qualified domain name) in the era of virtual machines, but IP address-based identification is vulnerable to multiple services sharing an IP address, IP address forgery, and oversized access control lists. Because containers have a short lifecycle in the Kubernetes era, instead of an IP address, we rely on a pod or service name. However, different clouds and software platforms approach workload identity differently, and there are compatibility issues. This is especially true in heterogeneous hybrid clouds, where workloads run on both virtual machines and Kubernetes. It is critical to establish a fine-grained, interoperable identification system at this point. This is where SPIFFE shines.

When each microservice instance is run in Gloo Platform, it is a given a unique identifier. The microservice uses the identifier to communicate with other microservices in the same Gloo Platform mesh. The identifier can be used in two-way authentication to allow or deny access to a service. The identifier can also be used in authorization policies.

Service identities in Gloo Platform comply with SPIFFE and are in the following format:
=spiffe://<trust-domain>/ns/<namespace>/sa/<service-account>=
* SPIRE
As mentioned above, service identities generated by Istio's identity mechanism are based on Kubernetes service accounts. This is some what restrictive specially for scenarios where you cant rely on the service accounts alone. For example think of a scenario where a misconfiguration caused multiple workloads to get deployed with the same service account. Now you may have compromised the whole security posture of your mesh.

What if theres a way around this restriction ? Well there is. Its called SPIRE, an opensource runtime for SPIFFE. SPIRE performs node and workload attestation in order to securely issue identities to workloads. SPIRE supplies a broad and extendable set of selectors. It provides both a set of built-in plugins and a mechanism to use external plugins. These allow administrators to configure SPIRE to issue identities based on a multitude of conditions. Workloads could be attested based, for instance, on a combination of Kubernetes properties and conditions based on metadata values from a public-cloud system.

SPIRE has direct integration with Istio and allows operators to completely bypass Istio's native identity system.
* Service-to-service Mutual TLS (mTLS)
This is one of the most important subjects to discuss when it comes to ZTA. Managing secure communication between participating services is one of the challenges organizations repeatedly face when using microservices-based solutions.

Mutual TLS authentication (mTLS) refers to two parties authenticating each other at the same time. Which means that mtls ensures that traffic is secured in both the directions between client and server. In this case, the server only accepts the connections for the clients registered with the server certificate authority. This is what pretty much happens in mTls, where the connection of both the sides verify the certificates. Another role of mTLS is to validate the identity of the workload using the SPIFFE framework described earlier.
* istio mTLS deep-dive
By default, within the mesh Istio encrypts client-to-server hence mTLS is automatically enabled. This means that while services accept both plain-text and TLS traffic, by default, services will send TLS requests but this is only applicable internally in the mesh.

Istio can run in two mTLS modes,

- Permissive (by default) - Can accept both encrypted and plain-text traffic.
- Strict - Services can only accept encrypted traffic
* Inter-service Authorization
While mTLS solves the authentication of services, this alone is not always enough to fully secure traffic. Authorization also plays a critical part in ZTA inter-service communication. As an operator of the mesh it takes effort to configure the correct authorization policies to best protect your microservice architectures. Its important to note in Istio that DENY policies take precedence over the ALLOW policies.

Recommended set of authorization policy patterns,

- default-deny policy - default-deny means your system denies all requests by default, and conditions in which the requests are allowed have to be explicitly defined. In case these conditions are misconfigured, traffic will be unexpectedly denied, instead of traffic being unexpectedly allowed.
- Deny on empty principal - This enforces defense-in-depth in addition to mTLS by denying the request if the principal is empty. Istio automatically extracts the identity from the peer authentication into the source.principal.
- Deny on empty request principal - This is useful if the request principal must be enforced as non-empty extracted after validating JWT tokens.

** Deny all
#+begin_src yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: istio-config
spec:
  {}
#+end_src

** Allow specific
#+begin_src yaml
kubectl --context $WEST_CONTEXT apply -f - <<EOF
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: "allow-access-to-httpbin"
  namespace: httpbin-trusted
spec:
  selector:
    matchLabels:
      app: httpbin
  action: ALLOW
  rules:
    - from:
      - source:
          principals: ["cluster.local/ns/http-client-trusted/sa/http-client"]
      to:
        - operation:
            methods: ["GET"]
EOF
#+end_src

* Security audits
Auditing your services helps you answer the questions "who did what, when, and possibly why." With an audit policy, you can specify when an audit log is created and the content of the logs. A request will be internally marked that it should be audited if there is an authorization policy (AuthorizationPolicy) with action AUDIT on the workload that matches the request. Currently, only supported audit plugin in Istio is Stackdriver.

#+begin_src yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: "audit-httpbin"
  namespace: httpbin-trusted
spec:
  selector:
    matchLabels:
      app: httpbin
  action: AUDIT
  rules:
    - to:
        - operation:
            methods: ["GET"]
#+end_src
* Access Logs
Access logs are useful to verify the policy that is being triggered when a request is being denied.
#+begin_src shell
kubectl --context $WEST_CONTEXT exec -n http-client-trusted deploy/http-client -- curl -is http://httpbin.httpbin-trusted:8000/get
#+end_src
* Policy Statistics
Istio proxies generate statistics for requests being allowed or denied.
#+begin_src shell
kubectl --context $WEST_CONTEXT exec deploy/httpbin -n httpbin-trusted -c istio-proxy -- curl -s http://localhost:15000/stats | grep "http.inbound_0.0.0.0_80.rbac."
#+end_src
* Workspaces
#+begin_src shell
envsubst < <(cat 03-gloo-platform-workspaces/workspace-settings-ops-team.yaml) | kubectl --context $MGMT_CONTEXT apply -n ops-team -f -
#+end_src
